## **数组**

### 颜色排序

[LeetCode 75](<https://leetcode-cn.com/problems/sort-colors/>)

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:不能使用代码库中的排序函数来解决这道题。

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

#### 解题思路

1. ##### 计数排序思想

- 第一次遍历数组，迭代计算为0、 1 和 2 的元素个数；
- 第二次遍历，按照0，1，2 的排序，重写当前数组。

时间复杂度为 O(n)；空间复杂度为 O(k)（元素种类为 k，这里  `k=3` ,创建了 `int[] cnts = new int[3];` ）。

```java
//leetcode-75
//采用计数排序
class Solution {
    public void sortColors(int[] nums) {
        int[] cnts = new int[3];
        for(int num : nums){
            if(num == 0){
                cnts[0]++;
            }else if(num == 1){
                cnts[1]++;
            }else{
                cnts[2]++;
            }
        }
        for(int i = 0;i < nums.length;i++){
            if(i < cnts[0]){
                nums[i] = 0;
            }else if(i >= cnts[0] && i < cnts[0] + cnts[1]){
                nums[i] = 1;
            
            }else{
                nums[i] = 2;
            }
        }        
    }
}
```

2. ##### 三路快排

时间复杂度为 O(n)；不需要额外空间。

```java
class Solution {
    public void sortColors(int[] nums) {
        int l = -1;//nums[0...l] == 0
        int h = nums.length;//nums[h...nums.length-1] == 2
        for(int i = 0;i < h;){
            if(nums[i] == 1){
                i++;
            }else if(nums[i] == 2){
                h--;
                swap(nums, i, h);
            }else{
                l++;
                swap(nums, i, l);
                i++;
            }            
        }        
    }
    private void swap(int[] nums,int a,int b){
        int t = nums[a];
        nums[a] = nums[b];
        nums[b] = t;
    }
}
```

[leetcode-88](<https://leetcode-cn.com/problems/merge-sorted-array/>)

[leetcode-215](<https://leetcode-cn.com/problems/kth-largest-element-in-an-array/>)

### 二维数组中的查找

[nowcoder](<https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 解题思路

- 需要充分利用该二维数组的特点（从左到右递增排序，从上到下也是递增排序），找出解题方法。
- 从**右上角/左下角**开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间
- 没有单独处理输入数组为空或非二维数组的情况。**要先对特殊情况做处理**。

```java
public class Solution {
    public boolean Find(int target, int [][] array) {
        //若输入的不是二维数组，返回false
        if(array==null||array.length==0||array[0].length==0)
            return false;
        //从数组的右上角开始与target比较
        int row=0;
        int col=array[0].length-1;
        while(row<array.length&&col>=0){
            if(target>array[row][col])
                row++;
            else if(target<array[row][col])
                col--;
            else
                return true;
        }
        return false;
    }
}
```

### 数组中重复的数字

[nowcoder](<https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组 {2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字 2。

#### 解题思路

对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。

以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复。

```java
/*
将值为i的元素调整到第i个位置上
调整前比较当前值为i的元素与第i个位置上的元素值是否相等
若相等，则该元素值重复
*/
public class Solution {
    public boolean duplicate(int[] numbers,int length,int [] duplication) {
        //输入数组为空或数组长度不符合
        if(numbers==null||length<=0){
            return false;
        }
        //遍历数组元素
        for(int i=0;i<length;i++){
            if(numbers[i]<0||numbers[i]>=length)
                return false;//判断数组元素是否在规定范围内
            while(numbers[i]!=i){//直到numbers[i]==i时，才会i++，比较下一个
                if(numbers[i]==numbers[numbers[i]]){
                    duplication[0]=numbers[i];//出现重复数字
                    return true;
                }
                swap(numbers,numbers[i],i);
            }
        }
        return false;
    }
    public void swap(int[] numbers,int x,int y){
        int temp=numbers[y];
        numbers[y]=numbers[x];
        numbers[x]=temp;
    }
}
```

### 调整数组顺序使奇数位于偶数前面

[nowcoder](<https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

#### 解题思路

注意要满足奇数之间、偶数之间相对位置不变，主要有两种方法：

- 创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)
- 冒泡思想，每次将当前偶数上浮到当前右侧，时间复杂度 O(N^2^)，空间复杂度 O(1)

```java
//1.1 创建一个新数组，时间复杂度O(N)，空间复杂度 O(N)
//遍历原数据，将奇数按序保存在原数组，将偶数依序保存在新数组cur1
//遍历结束，将cur1中的偶数部分复制到原数组的奇数后面
public class Solution {
    public void reOrderArray(int [] array) {
        int[] arrEven=new int[array.length];
        int curOdd=0,curEven=0;
        for(int i=0;i<array.length;i++){
            if(array[i]%2==0){//是偶数，存入arrEven
                arrEven[curEven++]=array[i];
            }else{//是奇数，存入array
                array[curOdd++]=array[i];
            }
        }
        //将arrEven复制到奇数的后面        System.arraycopy(arrEven,0,array,curOdd,curEven);
    }
}

//1.2 创建一个新数组，时间复杂度O(N)，空间复杂度 O(N)
public class Solution {
    public void reOrderArray(int [] array) {
        int oddCnt=0;
        //先计算出奇数个数
        for(int x:array){
            if(!isEven(x))
                oddCnt++;
        }
        //再依次将原数组中元素复制到新数组中
        int[] copy = array.clone();
        int i=0;
        for(int x:copy){
            if(!isEven(x))
                array[i++]=x;
            else
                array[oddCnt++]=x;
        }
    }
    private boolean isEven(int x){
        return x%2==0;
    }
}

//冒泡，每次将偶数移到数组最右侧
public class Solution {
    public void reOrderArray(int [] array) {
        for(int i=array.length-1;i>0;i--){
            for(int j=0;j<i;j++){
                if(isEven(array[j])&&!isEven(array[j+1]))
                    swap(array,j,j+1);
            }
        }
    }
    private boolean isEven(int x){
        return x%2==0;
    }
    //交换数组中第i、j个元素
    //利用加减法实现交换，不需要中间元素
    private void swap(int[] array,int i,int j){
        array[i]=array[i]-array[j];
        array[j]=array[i]+array[j];
        array[i]=array[j]-array[i];
    }
}
```

### 顺时针打印矩阵

[nowcoder](<https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下 4 X 4 矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

#### 解题思路

- 每一圈遍历需要四个循环，确定循环的起始和终止点
- 同时在每一圈第二次打印一列或一行的时候要判断是否重复打印

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList<Integer> ret = new ArrayList<>();
        int r1=0,r2=matrix.length-1;
        int c1=0,c2=matrix[0].length-1;
        while(r1<=r2&&c1<=c2){
        	//从左向右打印
            for(int i=c1;i<=c2;i++)
                ret.add(matrix[r1][i]);
            //从上往下的每一列数据
            for(int i=r1+1;i<=r2;i++)
                ret.add(matrix[i][c2]);
            //判断是否会重复打印（从右向左的每行数据）
            if(r1!=r2){
                for(int i=c2-1;i>=c1;i--)
                    ret.add(matrix[r2][i]);
            }
            //判断是否会重复打印（从从下往上的每列数据）
            if(c1!=c2){
                for(int i=r2-1;i>r1;i--)
                    ret.add(matrix[i][c1]);
            }
            r1++; r2--; c1++; c2--;
        }
        return ret;
    }
}
```



## **查找**

### 矩阵中的路径

[nowcoder](<https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的 3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

#### 解题思路

使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。

- 将一维数组转化为矩阵（二维数组），同时创建一个矩阵 marked 用于记录对应位置的 matrix 格子是否已经被进入过
- 依次遍历整个矩阵，设定该格子为第一步进入的格子：
  1. 若路径长度（初始为 0，当确认当前格子符合条件后，pathLen+1）等于字符串长度，说明已经包含了字符串所有字符，不用再继续向四周搜索，返回 true
  2. 若行或列不在[0,rows/cols) 之间||当前格子值不等于对应字符值，||当前格子已经被进入过，说明该格子不是正确的路径，返回 false
  3. 若当前格子符合条件，进入该格子，继续调用 backtracking(),一层层向下寻找周边符合条件的路径，直到 pathLen==str.length()，即符合 1，搜索完成，一层层的返回 true
  4. 相邻格子不符合条件，返回 false
  5. 2 和 4 中返回 false 后，会回溯到上一个格子后，继续搜索下一相邻的格子，若周围四个格子都不符合，那么会返回 false，继续向上回溯。

```java
public class Solution {
    private final static int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
    private int rows;
    private int cols;
    public boolean hasPath(char[] array, int rows, int cols, char[] str){
        if(rows==0||cols==0)
            return false;//一维向量，返回false
        this.rows=rows;
        this.cols=cols;
        boolean[][] marked=new boolean[rows][cols];//用于记录当前格子是否已经进入过
        char[][] matrix=buildMatrix(array);
        //路径开始的位置，即第一个进入的格子
        for(int i=0;i<rows;i++){
                for(int j=0;j<cols;j++){
                    if (backtracking(matrix, str, marked, 0, i, j))
                        return true;
                }
        }
        return false;
        }
    public boolean backtracking(char[][] matrix, char[] str,
                                boolean[][] marked, int pathLen, int r, int c){
        if(pathLen==str.length)
            return true;//1.若路径长度等于字符串长度，返回true
        //2.若行或列不在[0,rows/cols)之间||当前格子值不等于对应字符值，||当前格子已经被进入过，返回false
        if(r<0||r>=rows||c<0||c>=cols||matrix[r][c]!=str[pathLen]||marked[r][c])
            return false;
        //否则进入该格子，当前marked设为true
        marked[r][c]=true;
        //寻找下一条路径，查看该格子的四周（r,c-1),(r,c+1),(r-1,c),(r+1,c)
        for (int[] n : next)//遍历二维数组中每一个一维数组
            //3.不断调用backtracking(),一层层向下寻找周边符合条件的路径，直到pathLen==str.length()，一层层的返回true
            if (backtracking(matrix, str, marked, pathLen + 1, r + n[0], c + n[1]))
                return true;
        marked[r][c] = false;
        //4.下一相邻格子不符合条件，返回false
        return false;
    }
        //将数组转化为矩阵（二维数组）结构
        private char[][] buildMatrix(char[] array){
            char[][] matrix=new char[rows][cols];
            for(int r=0,idx=0;r<rows;r++){
                for(int c=0;c<cols;c++){
                    matrix[r][c]=array[idx++];
                }
            }
            return matrix;
        }
}
```

### 机器人的运动范围

[nowcoder](<https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

地上有一个 m 行和 n 列的方格。一个机器人从坐标 0,0 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。 例如，当 k 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 = 18。但是，它不能进入方格（35,38），因为 3+5+3+8 = 19。请问该机器人能够达到多少个格子？

#### 解题思路

使用深度优先搜索（Depth First Search，DFS）方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。

```java
public class Solution {
    private final static int[][] next={{1,0},{-1,0},{0,1},{0,-1}};
    private int cnt = 0;
    private int rows;
    private int cols;
    private int threshold;
    private int[][] digitSum;
    public int movingCount(int threshold, int rows, int cols)
    {
        this.rows=rows;
        this.cols=cols;
        this.threshold=threshold;
        //if(rows==0||cols==0) return 0;
        boolean[][] marked=new boolean[rows][cols];//用于标记是否到达过
        initDigitSum();//将m*n方格的坐标之和存储在digitSum[][]中
        dfs(marked,0,0);//从（0，0）格开始移动
        return cnt;
    }
    private void dfs(boolean[][] marked, int r, int c) {
        if(r<0||r>=rows||c<0||c>=cols||marked[r][c])
            return;//若超过边界或该格子曾经进入过，返回上一层
        marked[r][c]=true;//该格子已经搜索过，标志设为true
        if (this.digitSum[r][c] > this.threshold)
            return;//如果位数和大于阈值，不能进入，返回上一层
        cnt++;//进入该格子，计数加一
        for(int[] n:next)
            dfs(marked,r+n[0],c+n[1]);//继续搜索周边的格子
    }
    
    private void initDigitSum(){
        //将0-max（行坐标和列坐标中最大值的）之间所有数的位数之和求出，放入数组digitSumOne中
        int [] digitSumOne=new int[Math.max(rows,cols)];
        for(int i=0;i<digitSumOne.length;i++){
            int n=i;
            //0-max之间的位数从低位开始依次相加
            while(n>0){
                digitSumOne[i]+=n%10;
                n/=10;
            }
        }
        //调用digitSumOne[]，将每个方格的行、列坐标的数位之和全部求出，存储在二维数组中
        this.digitSum=new int[rows][cols];
        for(int i=0;i<rows;i++)
            for(int j=0;j<cols;j++)
                digitSum[i][j]=digitSumOne[i]+digitSumOne[j];
    }
}
```

### 旋转数组的最小数字

[nowcoder](<https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组 {3,4,5,1,2} 为 {1,2,3,4,5} 的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。

#### 解题思路

- 第一次做只会采用顺序查找，想不到如何利用原始数组的**非减排序**性质。
- 将旋转数组对半分，包含最小值的一段仍然是旋转数组，另一段是非减排序的数组
- 关键在于如何判断出：哪一个是旋转数组，哪一个是非递减数组
  - 当 nums[m] <= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m；
  - 否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。
- 还需要注意一种特殊情况（1 1 1 0 1），这时 nums[m] =nums[l] =nums[h] ，无法判断出旋转数组是哪一侧，只能切换为顺序查找
- 时间复杂度：顺序查找 O(N)；二分查找 O(logN )

```java
//直接遍历查找最小值，时间复杂度 O(N)
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length==0)
            return 0;
        int min=array[0];
        for(int i=1;i<array.length;i++){
            min=array[i]< min?array[i]:min;
        }
        return min;
    }
}

//折半查找
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length==0)
            return 0;
        int low=0,high=array.length-1;
        while(low<high){
            int mid=(low+high)/2;
            //若所取的三个值相等（1 1 1 0 1），无法判断哪边是旋转数组
            //应切换到顺序查找           if(array[mid]==array[low]&&array[low]==array[high])
                return minNumber(array,low,high);//顺序查找
            //否则进行二分查找，判断哪边是旋转数组
            else if(array[mid]<=array[high])
                high=mid;
            else
                low=mid+1;
        }
        return array[high];    
    }
     private int minNumber(int [] array,int low,int high) {
        int min=array[low];
        for(int i=low+1;i<=high;i++){
            min=array[i]< min?array[i]:min;
        }
        return min;
     }
}
```



## **字符串**

### 替换空格

[nowcoder](<https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。

#### 解题思路

- 先遍历一遍，确定空格数量，每有一个空格在 str 尾部填充两个字符；
- 再由后向前遍历，这里设置 P1（指向原字符串末尾后面一个位置）, P2（指向添加空格后的新字符串末尾后面一个位置） 两个指针，根据 P1 向前遍历的结果，确定当前 P2 位置的内容；
  - 若 P1 位置为空格，则 P2 位置及其前两个位置依次改为 ’0‘，’2‘，’%‘；
  - 若 P1 位置不为空格，则 P2 位置改为 当前 P1 位置存储的字符 c。
- 要注意**索引下标**的正确性，P--，--P 要仔细考虑一下，否则会出现越界错误：java.lang.StringIndexOutOfBoundsException: String index out of range: -1

```java
public class Solution {
    public String replaceSpace(StringBuffer str) {
        int P1=str.length();
        //先遍历一遍，确定空格数量，每有一个空格在str尾部填充两个字符
        for(int i=0;i<P1;i++){
            if(str.charAt(i)==' ')
                str.append("  ");//尾部添加两个空格
        }
        //由后向前遍历，不会影响到P1遍历原来字符串的内容
        int P2=str.length();
        while(P1>0||P1<P2){
            char c=str.charAt(--P1);
            if(c==' '){
                str.setCharAt(--P2,'0');
                str.setCharAt(--P2,'2');
                str.setCharAt(--P2,'%');
            }
            else{
                str.setCharAt(--P2,c);
            }
        }
        return str.toString();
    }
}
```

### 正则表达式匹配

[nowcoder](<https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

请实现一个函数用来匹配包括 '.' 和 '\*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '\*' 表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 (str)"aaa"与模式 (pattern)"a.a"和"ab\*ac\*a"匹配，但是与"aa.a"和"ab\*a"均不匹配。

#### 解题思路

- str[i]==pattern[j]||pattern[j]='.' 时，当前字符是匹配的

- 先看 '\*'，当 pattern[j+1]=='*' 时，

  再看匹配

  1. 若 str[i] 与 pattern[j] 匹配，则 match(str,i+1,pattern,j)||match(str,i ,pattern,j+2)
  2. 若 str[i] 与 pattern[j] 不匹配，则 match(str,i,pattern,j+2)

  当 pattern[j+1]！='*' 时，match(str,i+1,pattern,j+1)

- 先看匹配，用 first_isMatch 记录当前是否匹配

  再看下一个字符是否为 '*'

  1. 为 '/*' ,match(str,i,pattern,j + 2)||(first_isMatch && match(str,i + 1,pattern,j))
  2. 不为 '/*' ，first_isMatch && match(str,i + 1,pattern,j + 1)

- 以上是**递归法**，需要注意**数组的索引不能越界**

- 也可采用**动态规划**

  1. 建立一个数组 boolean[][] dp=new boolean[str.length+1] [pattern.length+1];，从末尾开始匹配,str 和 pattern 末尾都是空，dp[str.length] [pattern.length]=true

  2. 创建两重循环，遍历 dp，在遍历过程中建立 dp 数字值之间的关系（参考递归调用），同样也有两种方式

     match(str,i,pattern,j+2) 即为 dp[i] [j]=dp[i] [j+2]

```java

public class Solution {
    public boolean match(char[] str, char[] pattern){
        if(str==null||pattern==null)
            return false;
        boolean[][] dp=new boolean[str.length+1][pattern.length+1];
        //从末尾开始匹配,str和pattern末尾都是空，匹配结果一定为true
        dp[str.length][pattern.length]=true;
        for(int i=str.length;i>=0;i--){
            for(int j=pattern.length-1;j>=0;j--){
             	//下一个为'*'
                if(j<pattern.length-1&&pattern[j+1]=='*'){
                    if(i!=str.length&&(str[i]==pattern[j]||pattern[j]=='.'))
                        dp[i][j]=dp[i+1][j]||dp[i][j+2];//当前匹配
                    else
                        dp[i][j]=dp[i][j+2];//当前不匹配
                }else{
                //下一个不为'*'
                    if(i!=str.length&&(str[i]==pattern[j]||pattern[j]=='.'))
                        dp[i][j]=dp[i+1][j+1];
                }
            }
        }
        return dp[0][0];
    }
}

//动态规划
public class Solution {
    public boolean match(char[] str, char[] pattern){
        if(str==null||pattern==null)
            return false;
        boolean[][] dp=new boolean[str.length+1][pattern.length+1];
        //从末尾开始匹配,str和pattern末尾都是空，匹配结果一定为true
        dp[str.length][pattern.length]=true;
        for(int i=str.length;i>=0;i--){
            for(int j=pattern.length-1;j>=0;j--){
                boolean first_isMatch=(i!=str.length)&&
            (str[i]==pattern[j]||pattern[j]=='.');
                //下一个为'*'
                if(j<pattern.length-1&&pattern[j+1]=='*')
                    dp[i][j]=dp[i][j+2]||(first_isMatch&&dp[i+1][j]);
                //下一个不为'*'
                else
                dp[i][j]=first_isMatch&&dp[i+1][j+1];
            }
        }
        return dp[0][0];
    }
}
```

### 表示数值的字符串

[nowcoder](<https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 "+100" ,"5e2" ,"-123" ,"3.1416" 和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

#### 解题思路

- String.matchs() 方法，需要将 char[] 转换为字符串
- 使用正则表达式进行匹配 [+-]?\\\\d*(\\\\.\\\\d+)?([eE]\[+-]?\\d+)?

|        [+-]?        | 正或负符号出现与否                                           |
| :-----------------: | :----------------------------------------------------------- |
|        \\\d*        | 整数部分是否出现，如-.34 或 +3.34均符合                      |
|   (\\\\.\\\\d+)?    | 如果出现小数点，那么小数点后面必须有数字；否则都不出现       |
| ([eE]\[+-]?\\\\d+)? | 如果存在指数部分，那么e或E肯定出现，+或-可以不出现，紧接着必须跟着整数；或者整个部分都不出现 |

```java
public class Solution {
    public boolean isNumeric(char[] str) {
        if (str == null || str.length == 0)
            return false;
        return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
    }
}
```



## **栈**

### 用两个栈实现队列

[nowcoder](<https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。

#### 解题思路

- 两个栈，一个栈（in）处理入栈操作，一个栈（out）处理出栈操作。
- 队列先进先出，而栈后进先出，关键在于出队前，需要将栈中元素顺序进行反转，故每次 pop 操作需要将 in 中元素 pop 并依序 push 到 out 中，实现顺序的反转，再进行出队 pop 操作。
- 若考虑到 push 和 pop 是多次操作的，那么第二次 push 操作，也需要用同样的方法将新的队列从 out 栈中 push 到 in 栈中，再进行入队 push 操作。
- **进时，栈 out 是否为空，不为空，则栈 out 元素倒回到栈 in，出时，将栈 in 元素全部弹到栈 out 中，直到栈 in 为空。**

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> in = new Stack<Integer>();
    Stack<Integer> out = new Stack<Integer>();
    //push:若in队列为空，则将out依次弹出，并push到in，实现栈中顺序的反转
    public void push(int node)  throws Exception {
        if(in.isEmpty()){
            while(!out.isEmpty())
                in.push(out.pop());
        }
        in.push(node);//push本次的新结点进入队列
    }
    //pop:若out队列为空，则将in依次弹出，并push到out，实现栈中顺序的反转
    public int pop() throws Exception {
        if(out.isEmpty()){
            while(!in.isEmpty())
                out.push(in.pop());
        }
        return out.pop();
    }
}
```

### 包含 min 函数的栈

[nowcoder](<https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。

#### 解题思路

利用一个辅助栈来存放最小值 

​      栈  3，4，2，5，1

​      辅助栈 3，3，2，2，1

  每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶 

  当出栈时，辅助栈也要出栈 

  这种做法可以保证辅助栈顶一定都当前栈的最小值

```java
import java.util.Stack;

public class Solution {
    private Stack<Integer> dataStack = new Stack<>();
    private Stack<Integer> minStack = new Stack<>();
    //dataStack用于存储栈值
    //minStack用于保存当前入栈元素中的最小值
    public void push(int node) {
        dataStack.push(node);
        //若栈为空，直接入栈；若不为空，将栈顶元素和node中较小值入栈
        minStack.push(minStack.isEmpty()?node:Math.min(node,minStack.peek()));
    }
    
    public void pop() {
        dataStack.pop();
        minStack.pop();
    }
    
    public int top() {
        return dataStack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```

### 栈的压入、弹出序列

[nowcoder](<https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。

例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。

#### 解题思路

- 利用一个栈来模拟这个过程：

  - 每次压入判断当前栈顶元素是否与当前 popA 元素相等，相等则依次弹出，popA 每次后移一位，直至栈顶元素与当前 popA 元素不等

  ```java
  while(s.peek()==popA[j]&&j<popA.length-1)
  ```

  - 不能将栈元素全部弹出，会出现栈空错误（java.util.EmptyStackException），所以限定 j<popA.length-1，最后 return s.peek()==popA[j];

- **EmptyStackException 错误**：

  是由于**调用 stackA.peek() 时，如果 stackA 为空将会返回 EmptyStackException 异常**。

  所以在 while 条件中要加入判断栈不为空的语句，而且由于**'&&' 的运算顺序**，需要先判断栈不为空，再取 s.peek()，判断与当前 popA 元素是否相等

```java
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        //若序列为空或者两序列长度不等        if(pushA.length==0||pushA.length!=popA.length)
            return false;
        Stack<Integer> s=new Stack<> ();
        int j=0;//作为popA数组的索引
        for(int i=0;i<pushA.length;i++){
            s.push(pushA[i]);//依次将pushA中元素压入数组
            //每次压入判断当前栈顶元素是否与当前popA元素相等
            //相等则依次弹出，popA每次后移一位，直至栈顶元素与当前popA元素不等
            //不能将栈元素全部弹出，会出现栈空错误（java.util.EmptyStackException），所以限定j<popA.length-1
            while(s.peek()==popA[j]&&j<popA.length-1){
                s.pop();
                j++;
            }
        }
        return s.peek()==popA[j];
    }
}

import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA.length==0||pushA.length!=popA.length)
            return false;
        Stack<Integer> s=new Stack<Integer> ();
        for(int i=0,j=0;i<pushA.length;i++){
            s.push(pushA[i]);
            while(!s.isEmpty()&&j<popA.length&&s.peek()==popA[j]){
                s.pop();
                j++;
            }
        }
        return s.isEmpty();
    }
}
```

### 有效的括号

[LeetCode 20](<https://leetcode-cn.com/problems/valid-parentheses/>)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

#### 解题思路

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        char [] c = s.toCharArray();
        for(int i = 0 ; i < c.length ; i ++){
            //左括号入栈
            if(c[i] == '(' || c[i] == '[' || c[i] == '{'){
                stack.push(c[i]);
            }else{
                //若栈为空，那么已经没有左括号与当前的右括号 c[i] 匹配，返回 false
                if(stack.size() == 0)
                    return false; 
                //弹出栈顶的左括号
                char top = stack.pop();//保存栈顶元素
                //根据当前 c[i] 的字符，得出与其匹配的左括号类型
                char match = 'a';//保存预期的左括号
                if(c[i] == ')')
                    match = '(';
                else if (c[i] == ']')
                    match = '[';
                else{//c[i] == '}'
                    match = '{';
                }
                //若栈顶的左括号不是预期的字符，返回 false
                if(top != match)
                    return false;
                }
            }
        
        //若栈中还有左括号未被匹配，返回 false，否则返回 true 
        return stack.size() == 0;
        
    }
}
```

### 逆波兰表达式求值

[LeetCode 150](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

根据逆波兰表示法，求表达式的值。

有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

```java
输入: ["4", "13", "5", "/", "+"]
输出: 6
解释: (4 + (13 / 5)) = 6
```

#### 解题思路 

```java
//题目默认给定逆波兰表达式总是有效的
class Solution {
    public int evalRPN(String[] tokens) {
        //采用 Integer 类型的栈
        Stack <Integer> stack = new Stack <> ();
        for(String s : tokens){            
            switch(s){
                //遇到一个运算符，则弹出两个数来进行运算
                //对不同的运算符，进行指定的运算并将结果压栈            
                case "+":
                    stack.push(stack.pop() + stack.pop());
                    break;
                case "-":
                    stack.push(-stack.pop() + stack.pop());
                    break;
                case "*":
                    stack.push(stack.pop() * stack.pop());
                    break;
                case "/"://注意除数和被除数的顺序
                    Integer b = stack.pop();
                    Integer a = stack.pop();
                    stack.push(a / b);
                    break;
                default://非运算符，String 类型转换为 Integer 类型后压栈
                    stack.push(Integer.valueOf(s));
            }
        }
        return stack.pop();
    }
}
```



## **堆**





## **队列**



## **链表**

### 从尾到头打印链表

[nowcoder](<https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList。

#### 解题思路

三种方法：**递归，头插法，栈**

- 递归：需要明确**递归边界**和**递归逻辑**，**一层一层调用，直到递归结束条件成立，再一层一层返回**。配合 addAll()，按序将返回值添加到 ArrayList 尾部。

```java
/*
*使用递归
*不停的对listNode.next递归调用，直至最后一个结点
*再开始回溯插入ArrayList中，实现逆序
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> ret=new ArrayList<> ();
        if(listNode!=null){
            //addAll()按照返回的元素顺序，插入到arrayList中
            ret.addAll(printListFromTailToHead(listNode.next));//递归调用
            ret.add(listNode.val);//当前结点值插入arrayList
        }
        return ret;
    }
}
```

- 头插法：

  - 直接用 add(index=0,element) 头插法构建 ArrayList
  - 用头插法构建逆序链表,再用 add(element) 尾插法构建 ArrayList

```java
/*
*使用 add(0,listNode.val) 头插法实现逆序
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> ret=new ArrayList<> ();
        while(listNode!=null){
            ret.add(0,listNode.val);//头插法
            listNode=listNode.next;
        }
        return ret;
    }
}

/*
*使用头插法构建逆序链表
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //头插法构建逆序链表
        ListNode head=new ListNode(-1);//创建头结点
        while(listNode!=null){
            ListNode temp=listNode.next;//temp保存下一个结点位置
            //将当前结点插入head后面
            listNode.next=head.next;
            head.next=listNode;
            //将temp保存位置赋给listNode，准备开始下一次循环
            listNode=temp;
        }
        //构建ArrayList
        ArrayList<Integer> ret=new ArrayList<> ();
        head=head.next;
        while(head!=null){
            ret.add(head.val);//尾插法
            head=head.next;
        }
        return ret;
    }
}
```

- 利用栈的 LIFO 性质，stack.push()，stack.pop()。

  区分：stack.peek() 只返回栈顶的值，不删除栈顶的值

```java
/*
*利用栈的LIFO性质
*/
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //构建栈，将链表依序读入栈中
        Stack <Integer> stack=new Stack<>();
        while(listNode!=null){
            stack.push(listNode.val);
            listNode=listNode.next;
        }
        //构建ArrayList
        ArrayList<Integer> ret=new ArrayList<> ();
        //将栈中元素弹出直至栈空，实现逆序输出
        while(!stack.empty()){
            ret.add(stack.pop());
        }
        return ret;
    }
}
```

### 删除链表中重复的结点

[nowcoder](<https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1->2->3->3->4->4->5 处理后为 1->2->5

#### 解题思路

- 题意理解：**排序的链表**说明链表的节点值是有序的，即重复的结点是连续出现的；**重复的结点不保留**,是全部删除，而不是留下其中一个值。
- 递归思路：
  - 从头结点开始，若与下一节点值相同，则向下查找第一个不与头结点重复的节点 next，递归调用 return deleteDuplication（next）
  - 否则头结点是不重复的节点，应当保留，再重新对以头结点的下一节点 next 为头结点的链表进行删除重复节点操作，pHead.next=deleteDuplication（next）;这样可以将符合条件的头节点保留下来
- 非递归思路：
  - 首先，建立一个 first 头指针，指向 pHead，使得 pHead 和 pHead.next 能够用同样的方法来处理
  - 设定 p 为工作指针，不断向后搜索；last 指向当前确定不重复的指针
  - 如果 p.val\==p.next.val，则向后遍历查找第一个不等于 p.val 的节点 q，令 p=q，继续循环，判断 p 节点是否重复，直至 p.next\==null
  - 如果 p.val！=p.next.val，则节点 p 为不重复节点，用 next 加入到以 first 为头指针的返回链表中，p 继续指向下一节点，继续循环，判断 p 节点是否重复，直至 p.next==null

```java
public class Solution {
    public ListNode deleteDuplication(ListNode pHead){
        if(pHead==null||pHead.next==null) return pHead;
        ListNode next=pHead.next;
        //头结点重复，查找第一个不等于头结点的结点
        if(pHead.val==next.val){
            while(next!=null&&next.val==pHead.val)
                next=next.next;
            return deleteDuplication(next);
        }else{
        //头结点不重复，保留，对下一结点进行递归调用
            pHead.next=deleteDuplication(next);
            return pHead;
        }
         
    }
}

//非递归
public class Solution {
    public ListNode deleteDuplication(ListNode pHead){
        ListNode first = new ListNode(-1);
        first.next=pHead//将头指针pHead一般化，可以与其他指针统一处理
        ListNode next=first;//用于标记上一个已经判断不重复的节点
        ListNode p=pHead;//工作指针，不断向后搜索
        while(p!=null&&p.next!=null){
            if(p.val==p.next.val){
                int val=p.val;
                while(p!=null&&p.val!=val)
                    p=p.next;
                last.next=p;//找到第一个不等于val的节点，
            }else{
                last=p;//p为已判定的不重复节点
                p=p.next;
            }
        }
        return first.next;
    }
}
```

### 链表中倒数第 k 个结点

[nowcoder](<https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

输入一个链表，输出该链表中倒数第 k 个结点。

#### 解题思路

- 查找倒数第 k 个结点，关键在于链表的长度未知，只能从头开始沿着链表向后查找
- 注意考虑特殊情况：链表为空；k 值大于链表总长
- 两种方法
  1. 直接先求出链表总长，计算出倒数第 k 个结点的位置是 len-k+1
  2. 设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。

```java
//1. 直接先求出链表总长，计算出倒数第k个结点的位置是len-k+1
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null) return null;
        int len=0;
        ListNode cnt=head;
        while(cnt.next!=null){
            cnt=cnt.next;
            len++;
        }//求出链表的总长
        if(k>len+1) return null;//k超出链表总长
        cnt=head;
        for(int i=0;i<=len-k;i++){
            cnt=cnt.next;
        }//找出倒数第k个结点
        return cnt;
    }
}

//2. 采用两个指针p，q，先让p指向q后面第k个结点，然后p、q一起向后遍历
//当p到达末尾时，q当前指向的即为倒数第k个结点
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null) return null;//链表为空
        ListNode p=head;
        //p先向后移动k个结点
        while(p!=null&&k-->0){
            p=p.next;
        }
        if(k>0) return null;//k超出链表总长
        ListNode q=head;
        while(p!=null){
            p=p.next;
            q=q.next;
        }//同时向后移动直至p指向末尾
        return q;
    }
}
```

### 链表中环的入口结点

[nowcoder](<https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

#### 解题思路

- 画出示意图，利用两个速度不一的指针，得到入口结点的位置。
- 特殊情况：链表为空或不包含环状链

```java
public class Solution {
    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        if(pHead==null||pHead.next==null) return null;//链表为空
        ListNode slow=pHead.next;
        ListNode fast=slow.next;
        //fast每次后移两位，slow每次后移一位，直至相遇
        while(fast!=slow){
            slow=slow.next;
            fast=fast.next;
            fast=fast.next;
            if(fast==null||slow==null)
                return null;//不存在环状
        }
        //相遇后，令fast重回到头结点，每次向后移一位
        fast=pHead;
        while(fast!=slow){
            slow=slow.next;
            fast=fast.next;
        }
        return slow;
    }
}
```

### 反转链表

[nowcoder](<https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

输入一个链表，反转链表后，输出新链表的表头。

#### 解题思路

- **头插法**

  在插入过程要注意链表断裂连接过程和对结点的保存，避免丢失下一次操作所需的结点信息。写完之后可以举个简单的例子，走两次循环，看是否正确

- **递归**方法

  - 利用递归走到链表的末端，然后再更新每一个 node 的 next 值 (ListNode next=head.next; next.next=head;)，实现链表的反转
  - head.next=null;主要是为了使得反转链表的尾节点（即原链表的头结点）的 next 为 null
  - newhead 始终不变，是通过 newHead=ReverseList(next) 返回的，为该链表的最后一个结点

```java
//头插法
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null) return null;
        ListNode newHead=new ListNode(-1);
        while(head!=null){
            ListNode next=head.next;
            head.next=newHead.next;
            newHead.next=head;
            head=next;
        }
        return newHead.next;
    }
}

//递归
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode next=head.next;
        head.next=null;
        ListNode newHead=ReverseList(next);
        next.next=head;
        return newHead;
    }
}
```

### 合并两个排序的链表

[nowcoder](<https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

#### 解题思路

- **迭代**

  设定一个空的头结点，能够避免对第一次合并的单独处理。

- **递归**

  先根据简单的实例，将循环过程写出来，多思考一下如何转换为递归。

```java
//迭代
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode head=new ListNode(-1);
        ListNode cur = head;
        while(list1!=null&&list2!=null){
            if(list1.val<=list2.val){
                cur.next=list1;
                list1=list1.next;
            }else{
                cur.next=list2;
                list2=list2.next;
            }
            cur=cur.next;
        }
        if(list1==null) cur.next=list2;
        else cur.next=list1;
        return head.next;
    }
}

//递归
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        //若其中有链表为空
        if(list1==null||list2==null)
            return list1==null?list2:list1;
        if(list1.val<=list2.val){
            list1.next=Merge(list1.next,list2);
            return list1;
        }else{
            list2.next=Merge(list1,list2.next);
            return list2;
        }
    }
}
```



## **Map**



## **哈希表**



## **树**

### 重建二叉树

[nowcoder](<https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

#### 解题思路

- 前序遍历的第一个值为根节点的值，查找出该值在中序遍历中的位置，即可将其分为两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。接着进行递归重建左子树和右子树
- 通过画简单的示意图，确定左、右子树的前序遍历和中序遍历在两数组中的索引范围

**利用 HashMap**

```java
import java.util.HashMap;
public class Solution {
    private HashMap<Integer,Integer> indexForInOrders = new HashMap<>();
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        //用 HashMap 存储中序遍历的结果和索引
        for(int i=0;i<in.length;i++)
            indexForInOrders.put(in[i],i);
        return(reConstructBinaryTree(pre,0,pre.length-1,0));
    }
    //preL为树的起点，preR为树的终点，inL为中序遍历中树的起点
    private TreeNode reConstructBinaryTree(int [] pre,int preL,int preR,int inL){
        if(preL>preR)
            return null;
        TreeNode root=new TreeNode (pre[preL]);
        int inIndex=indexForInOrders.get(root.val);//中序遍历中查找根节点的索引值
        int leftTreeSize=inIndex-inL;//左子树的大小=根结点位置（中）-左子树起始位置（中）
        //要注意计算左右子树的范围
        root.left=reConstructBinaryTree(pre,preL+1,preL+leftTreeSize,inL);
        root.right=reConstructBinaryTree(pre,preL+leftTreeSize+1,preR,inIndex+1);
        return root;
    }
}
```

**直接遍历比较查找根节点**

```java
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        return reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);
    }
    //preL为树的起点，preR为树的终点，inL为中序遍历中树的起点
    private TreeNode reConstructBinaryTree(int [] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd){
        if(preStart>preEnd||inStart>inEnd)
            return null;
        TreeNode root=new TreeNode (pre[preStart]);
        for(int i=0;i<=inEnd;i++){
            if(in[i]==pre[preStart]){//在中序遍历中查找根节点的位置i
                int leftTreeSize=i-inStart;//左子树的大小=根结点位置（中）-左子树起始位置（中）
                //要注意计算左右子树的范围
                root.left=reConstructBinaryTree(pre,preStart+1,preStart+leftTreeSize,in,inStart,i-1);
                root.right=reConstructBinaryTree(pre,preStart+leftTreeSize+1,preEnd,in,i+1,inEnd);
                break;
            }
        }
        return root;
    }
}
```

### 二叉树的下一结点

[nowcoder](<https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

给定一个二叉树和其中的一个结点（pNode），请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

#### 解题思路

- 要注意到题目中给出的 TreeLinkNode next  即为当前结点指向父结点的指针
- 如果当前结点的右子树存在，那么返回右子树的最左叶子结点（即右子树中最先遍历的结点）
- 如果当前结点的右子树不存在：
  - 若当前结点为父结点的左结点，那么返回当前结点的父结点
  - 若当前结点为父结点的右结点，那么继续向上遍历父结点的父结点，直到找到一个结点是其父结点的左子结点，返回该结点

```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        //右子树为空，向上找第一个左链指向节点所在子树的祖先节点
        if(pNode.right==null){
            while(pNode.next!=null){
                TreeLinkNode parent=pNode.next;//父节点
                if(parent.left==pNode)
                    return parent;//若为左链，返回值
                pNode=parent;//非左链，继续向上遍历祖先节点
            }
            return null;
        }else{
            //右子树不为空，返回右子树的最左节点
            TreeLinkNode node=pNode.right;
            //沿左链一直向下遍历，直至叶子节点
            while(node.left!=null)
                node=node.left;
            return node;
        }
    }
}
```

### 树的子结构

[nowcoder](<https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

输入两棵二叉树 A，B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）

#### 解题思路

- **递归**，逻辑运算符 '||' 和 '&&' 的**短路特性**
- 参考思路：
  1. 在树 A 中找到和 B 的根节点的值一样的结点 R
  2. 判断树 A 中以 R 为根结点的子树是不是包含和树 B 一样的结构

```java
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2){
        if(root1==null||root2==null) return false;
        return isSubtreeWithRoot(root1,root2)||HasSubtree(root1.left,
        root2)||HasSubtree(root1.right,root2);
    }
    private boolean isSubtreeWithRoot(TreeNode root1,TreeNode root2){
        if(root2==null) return true;
        if(root1==null) return false;
        if(root1.val!=root2.val) return false;
        return isSubtreeWithRoot(root1.left,root2.left)&&
            isSubtreeWithRoot(root1.right,root2.right);
    }
}
```

### 二叉树的镜像

[nowcoder](<https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

操作给定的二叉树，将其变换为源二叉树的镜像。

```
二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
```

#### 解题思路

- **递归**，先交换根结点，再向下遍历交换所有的左右子结点
- 在 swap 方法中，互换的是左右结点，而每个子节点是与其根节点关联的，**交换节点对应子树也都对应交换**，但如果只是改变值，对应子节点由于绑定的地址未改变，所以位置不变，只是这个地址代表的值变了而已

```java
public class Solution {
    public void Mirror(TreeNode root) {
        if(root==null)
            return;
        swap(root);
        Mirror(root.left);
        Mirror(root.right);
    }
    private void swap(TreeNode root){
    //交换的是结点而非结点的值
        TreeNode t=new TreeNode(-1);
        t=root.left;
        root.left=root.right;
        root.right=t;
    }
}
```

### 对称的二叉树

[nowcoder](<https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

```
二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
```

#### 解题思路

- **递归**：

  1. 只要 pRoot.left 和 pRoot.right 是否对称即可
  2. 两结点的对称需要满足：左右节点的**值相等**&&**对称子树**（left.left，right.right; left.right, right.left） **也对称**，可以画出一个二叉树及其镜像树来理解。

- **栈**

  每次成对入栈，成对出栈，需要注意进栈的顺序，确保是每对互为镜像结点

- **队列**

  思路与栈的解法相同

  区别在于：

  - 栈：深度优先搜索（Depth First Search，DFS）
  - 队列：广度优先搜索（Breadth First Search，BFS），类似于树的层次遍历

```java
//1. 递归
public class Solution {
    boolean isSymmetrical(TreeNode pRoot){
        if(pRoot==null) return true;
        return isSymmetrical(pRoot.left,pRoot.right);
    }
    boolean isSymmetrical(TreeNode root1,TreeNode root2){
        if(root1==null&&root2==null) return true;
        if(root1==null||root2==null) return false;
        if(root1.val!=root2.val) return false;
        return isSymmetrical(root1.left,root2.right)&&
            isSymmetrical(root1.right,root2.left);
    }
}

//2. 利用栈
import java.util.Stack;
public class Solution {
    boolean isSymmetrical(TreeNode pRoot){
        if(pRoot==null) return true;
        Stack <TreeNode> s=new Stack<> ();
        s.push(pRoot.left);
        s.push(pRoot.right);
        while(!s.empty()){
            TreeNode right=s.pop();
            TreeNode left=s.pop();
            if(right==null&&left==null) continue;
            if(right==null||left==null) return false;
            if(right.val!=left.val) return false;
            s.push(left.left);
            s.push(right.right);
            s.push(left.right);
            s.push(right.left);
        }
        return true;
    }
}

//3. 利用队列
import java.util.*;
public class Solution {
    boolean isSymmetrical(TreeNode pRoot){
        if(pRoot==null) return true;
        Queue<TreeNode> s = new LinkedList<>();
        s.offer(pRoot.left);
        s.offer(pRoot.right);
        while(!s.isEmpty()){
            TreeNode right=s.poll();
            TreeNode left=s.poll();
            if(right==null&&left==null) continue;
            if(right==null||left==null) return false;
            if(right.val!=left.val) return false;
            s.offer(left.left);
            s.offer(right.right);
            s.offer(left.right);
            s.offer(right.left);
        }
        return true;
    }
}
```

### 从上往下打印二叉树

[nowcoder](<https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

#### 解题思路

考察的是二叉树的层次遍历（广度优先搜索 BFS）

借助一个队列实现层次遍历：

1. 每弹出一个结点，将该结点的左右子节点（若子节点不为空）压入栈，直至将栈全部弹空。
2. 设定一个值 cnt，在开始遍历一层结点时，记录当前栈的大小，即为当前层的结点数。遍历 cnt 个结点后，再进行下一层结点遍历。（该方法是后面两道题的基础）

```java
//借助一个队列保存某一层结点
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
         
        ArrayList<Integer> ret=new ArrayList<Integer>();
        if(root==null) return ret;
        //Queue<TreeNode> queue=new Queue<TreeNode>();
        //Queue queue=new Queue();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode cur=queue.poll();
            ret.add(cur.val);
            if(cur.left!=null) queue.offer(cur.left);
            if(cur.right!=null) queue.offer(cur.right);
        }
        return ret;
    }
}

//cnt 记录当前层的结点数
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> ret=new ArrayList<Integer>();
        if(root==null) return ret;
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int cnt=queue.size();
            while(cnt-->0){
                TreeNode cur=queue.poll();
                if(cur==null) continue;
                ret.add(cur.val);
                queue.offer(cur.left);
                queue.offer(cur.right);
            }
        }
        return ret;
    }
}

```



## **二叉搜索树**



## **深度优先搜索**



## **广度优先搜索**



## **递归**

### 斐波那契数列

[nowcoder](<https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。

n<=39

#### 解题思路

- 递归，每次递归需要重复计算子问题，效率极低，需要指数级时间（运行时间 1263 ms，占用内存 9272 K）
- 动态规划，建立一个数组，把子问题的解缓存起来，避免重复计算，需要线性时间，空间复杂度度为 O(N)
- 只存储前两项的值，空间复杂度为 O(1)
- 直接将前 40 项全部计算后保存

[浅谈动态规划](<https://blog.csdn.net/feizaoSYUACM/article/details/53846323>)

> 每个阶段只有一个状态->**递推**；
>
> 每个阶段的最优状态都是由上一个阶段的最优状态得到的->**贪心**；
>
> 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->**搜索**；
>
> 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->**动态规划**。

```java
//递归，每次递归需要重复计算子问题，时间效率低
public class Solution {
    public int Fibonacci(int n) {
        if(n<=1)
            return n;
        return Fibonacci(n-1)+Fibonacci(n-2);
    }
}

//动态规划
public class Solution {
    public int Fibonacci(int n) {
        if(n<=1)
            return n;
        int[] f=new int[n+1];
        f[1]=1;
        for(int i=2;i<n+1;i++)
            f[i]=f[i-1]+f[i-2];
        return f[n];
    }
}

//只存储前两项的值
public class Solution {
    public int Fibonacci(int n) {
        if(n<=1)
            return n;
        int p2=0,p1=1,f=0;
        for(int i=2;i<=n;i++){
            f=p2+p1;
            p2=p1;
            p1=f;
        }
        return f;
    }
}

//直接将前 40 项全部计算后保存
public class Solution {
    private int[] f=new int[40];
    public Solution(){
        f[1]=1;
        for(int i=2;i<f.length;i++){
            f[i]=f[i-1]+f[i-2];
        }
    }
    public int Fibonacci(int n) {
        return f[n];
    }
}
```



## **动态规划**

### 矩形覆盖

[nowcoder](<https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

我们可以用 2\*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2\*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共有多少种方法？

#### 解题思路

1. n<= 0 大矩形为 <= 2*0,直接 return 0； 

2. n= 1 大矩形为 2\*1，只有一种摆放方法，return 1；

3. n= 2 大矩形为 2\*2，有两种摆放方法，return 2；

4. n>2 分为两步考虑： 

   第一次摆放一块 2*1 的小矩阵，则摆放方法总共为 f(n- 1)

|  √   |      |      |      |      |
| :--: | ---- | ---- | ---- | ---- |
|  √   |      |      |      |      |

	第一次摆放一块 1*2 的小矩阵，则摆放方法总共为 f(n-2)

|  √   |  √   |      |      |      |
| :--: | :--: | ---- | ---- | ---- |
|      |      |      |      |      |

故：f(n)=f(n-1)+f(n-2)

```java
//斐波那契数列，动态规划
public class Solution {
    public int RectCover(int n) {
        if(n<=1)
            return n;
        int[] f=new int[n+1];
        f[1]=1;
        f[2]=2;
        for(int i=3;i<n+1;i++)
            f[i]=f[i-1]+f[i-2];
        return f[n];
    }
}
```

### 跳台阶

[nowcoder](<https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

#### 解题思路

```java
public class Solution {
    public int JumpFloor(int n) {
        if (n <= 2)
            return n;
        int pre2 = 1, pre1 = 2;
        int result = 1;
        for (int i = 2; i < n; i++) {
            result = pre2 + pre1;
            pre2 = pre1;
            pre1 = result;
        }
        return result;
    }
}
```

### 变态跳台阶

[nowcoder](<https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

#### 解题思路

- 动态规划，建立一个数组保存各个子问题的解，避免重复计算
- 数学推导，先推导出数学关系，后直接用公式计算

```java
//动态规划
public class Solution {
    public int JumpFloorII(int n) {
        int[] dp=new int[n+1];
        //设定初始值，保证 dp[1]=1,dp[2]=2
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            for(int j=0;j<i;j++){
            //dp[n]=dp[n-1]+...+dp[0]
                dp[i]+=dp[j];
            }
        }
        return dp[n];
    }
}

//数学推导出 f(n)=2*f(n-1)
public class Solution {
    public int JumpFloorII(int n) {         
        int[] result=new int[n+1];
        result[1]=1;
        for(int i=2;i<n+1;i++){
            result[i]=2*result[i-1];
        }
        return result[n];
    }
}
```



## **回溯算法**





## **分治算法**



## **位运算**



## **排序**



## **贪心算法**



## **并查集**



## **图**



## **数学**

### 二进制中 1 的个数

[nowcoder](<https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。

#### 解题思路

1. 对 n 的 2 进制形式进行右移操作，n&1 判断最右边是否为 1。

有符号位的右移操作，对于正数向右补 0，对于负数向右补 1。这里应该采用无符号位的右移操作

2. 对 1 进行左移操作，&  操作依次判断 n 的 2 进制形式每一位是否为 1。
3. 对最优解 n & (n-1) 方法的理解：

- 设 n = 1100，n-1 操作，n 最右边的 1 变为 0，1 之前的高位不变，1 之后的低位全为 1，即 1011
- n & (n-1) 操作，该 1 前面的高位不变，1 之后包括该位本身全为 0
- n 中含有几个 1，就能够进行几次 n & (n-1) 操作
- 最后一次操作后等于 0，作为跳出循环的标志 

```java
//1. 右移操作，n & 1 判断最右边是否为 1
public class Solution {
    public int NumberOf1(int n) {
        int cnt=0;
        int a=1;
        while(n!=0){
            if((n&a)==1)
                cnt++;
            n=n>>>1;
        }
        return cnt;
    }
}

//2. 对 1 进行左移操作
public class Solution {
    public int NumberOf1(int n) {
        int cnt=0;
        int flag=1;
        while(flag!=0){
            if((n&flag)!=0)
                cnt++;
            flag=flag<<1;
        }
        return cnt;
    }
}

//3. 最优解  n & (n-1)
public class Solution {
    public int NumberOf1(int n) {
        int cnt=0;
        while(n!=0){
            n&=n-1;
            cnt++;
        }
        return cnt;
    }
}
```

### 数值的整数次方

[nowcoder](<https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。

#### 解题思路

- 传统方法时间复杂度为 O(N)；递归方法，将复杂度降为 O(logN)。
- 要考虑指数运算中几种特殊情况，分别讨论。此外要注意指数为负数的情况。

```java
//传统公式求解
public class Solution {
    public double Power(double base, int exponent) {
        double power=base;
        if(exponent==0) return 1;//指数为0，返回1
        for(int i=1;i<Math.abs(exponent);i++)
            power*=base;
        return exponent>0?power:1/power;
  }
}

//递归
import java.lang.Math;
public class Solution {
    public double Power(double base, int exponent) {
        double power=base;
        if(exponent==0) return 1;
        if(exponent==1) return power;
        int exponentAbs=Math.abs(exponent);
        power=Power(base*base,exponentAbs>>1);
        if(exponentAbs%2!=0)
            power*=base;
        return exponent>0?power:1/power;
  }
}

//改进，考虑到 base 为 0 的情况
import java.lang.Math;
public class Solution {
    public double Power(double base, int exponent) {
        double power=base;
        if(base==0 && exponent<=0) 
            throw new RuntimeException();
        if(base==0&&exponent>0) return 0;
        if(exponent==0) return 1;
        if(exponent==1) return power;
        int exponentAbs=Math.abs(exponent);
        power=Power(base*base,exponentAbs>>1);
        if(exponentAbs%2!=0)
            power*=base;
        return exponent>0?power:1/power;
  }
}
```



## **设计**



## **拓扑排序**



## **字典树**



## **树状数组**



## **线段树**



## **脑筋急转弯**



## **记忆化**



## **极大化极小化**



## **蓄水池抽样**



## **几何**









