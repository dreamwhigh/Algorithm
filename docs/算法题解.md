## 数组

### LeetCode 75

[LeetCode 75](<https://leetcode-cn.com/problems/sort-colors/>)

#### 颜色排序

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:不能使用代码库中的排序函数来解决这道题。

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

#### **解题思路**

1. ##### **计数排序**思想

- 第一次遍历数组，迭代计算为0、 1 和 2 的元素个数；
- 第二次遍历，按照0，1，2 的排序，重写当前数组。

时间复杂度为 O(n)；空间复杂度为 O(k)（元素种类为 k，这里  `k=3` ,创建了 `int[] cnts = new int[3];` ）。

```java
//leetcode-75
//采用计数排序
class Solution {
    public void sortColors(int[] nums) {
        int[] cnts = new int[3];
        for(int num : nums){
            if(num == 0){
                cnts[0]++;
            }else if(num == 1){
                cnts[1]++;
            }else{
                cnts[2]++;
            }
        }
        for(int i = 0;i < nums.length;i++){
            if(i < cnts[0]){
                nums[i] = 0;
            }else if(i >= cnts[0] && i < cnts[0] + cnts[1]){
                nums[i] = 1;
            
            }else{
                nums[i] = 2;
            }
        }        
    }
}
```

2. ##### 三路快排

时间复杂度为 O(n)；不需要额外空间。

```java
class Solution {
    public void sortColors(int[] nums) {
        int l = -1;//nums[0...l] == 0
        int h = nums.length;//nums[h...nums.length-1] == 2
        for(int i = 0;i < h;){
            if(nums[i] == 1){
                i++;
            }else if(nums[i] == 2){
                h--;
                swap(nums, i, h);
            }else{
                l++;
                swap(nums, i, l);
                i++;
            }            
        }        
    }
    private void swap(int[] nums,int a,int b){
        int t = nums[a];
        nums[a] = nums[b];
        nums[b] = t;
    }
}
```

[leetcode-88](<https://leetcode-cn.com/problems/merge-sorted-array/>)

[leetcode-215](<https://leetcode-cn.com/problems/kth-largest-element-in-an-array/>)

### 二维数组中的查找

[nowcoder](<https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 解题思路

- 需要充分利用该二维数组的特点（从左到右递增排序，从上到下也是递增排序），找出解题方法。
- 从**右上角/左下角**开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间
- 没有单独处理输入数组为空或非二维数组的情况。**要先对特殊情况做处理**。

```java
public class Solution {
    public boolean Find(int target, int [][] array) {
        //若输入的不是二维数组，返回false
        if(array==null||array.length==0||array[0].length==0)
            return false;
        //从数组的右上角开始与target比较
        int row=0;
        int col=array[0].length-1;
        while(row<array.length&&col>=0){
            if(target>array[row][col])
                row++;
            else if(target<array[row][col])
                col--;
            else
                return true;
        }
        return false;
    }
}
```



## 字符串

### 替换空格

[nowcoder](<https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 解题思路

- 先遍历一遍，确定空格数量，每有一个空格在str尾部填充两个字符；
- 再由后向前遍历，这里设置 P1（指向原字符串末尾后面一个位置）, P2（指向添加空格后的新字符串末尾后面一个位置） 两个指针，根据 P1 向前遍历的结果，确定当前 P2 位置的内容；
  - 若 P1 位置为空格，则 P2 位置及其前两个位置依次改为 ’0‘，’2‘，’%‘；
  - 若 P1 位置不为空格，则 P2 位置改为 当前 P1 位置存储的字符 c。
- 要注意**索引下标**的正确性，P--，--P 要仔细考虑一下，否则会出现越界错误：java.lang.StringIndexOutOfBoundsException: String index out of range: -1

```java
public class Solution {
    public String replaceSpace(StringBuffer str) {
        int P1=str.length();
        //先遍历一遍，确定空格数量，每有一个空格在str尾部填充两个字符
        for(int i=0;i<P1;i++){
            if(str.charAt(i)==' ')
                str.append("  ");//尾部添加两个空格
        }
        //由后向前遍历，不会影响到P1遍历原来字符串的内容
        int P2=str.length();
        while(P1>0||P1<P2){
            char c=str.charAt(--P1);
            if(c==' '){
                str.setCharAt(--P2,'0');
                str.setCharAt(--P2,'2');
                str.setCharAt(--P2,'%');
            }
            else{
                str.setCharAt(--P2,c);
            }
        }
        return str.toString();
    }
}
```



## 栈



## 堆



## 队列



## 链表

### 从尾到头打印链表

[nowcoder](<https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

#### 解题思路

三种方法：**递归，头插法，栈**

- 递归：需要明确**递归边界**和**递归逻辑**，**一层一层调用，直到递归结束条件成立，再一层一层返回**。配合addAll()，按序将返回值添加到ArrayList尾部。

```java
/*
*使用递归
*不停的对listNode.next递归调用，直至最后一个结点
*再开始回溯插入ArrayList中，实现逆序
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> ret=new ArrayList<> ();
        if(listNode!=null){
            //addAll()按照返回的元素顺序，插入到arrayList中
            ret.addAll(printListFromTailToHead(listNode.next));//递归调用
            ret.add(listNode.val);//当前结点值插入arrayList
        }
        return ret;
    }
}
```

- 头插法：
  - 直接用add(index=0,element)头插法构建ArrayList
  - 用头插法构建逆序链表,再用add(element)尾插法构建ArrayList

```java
/*
*使用 add(0,listNode.val) 头插法实现逆序
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> ret=new ArrayList<> ();
        while(listNode!=null){
            ret.add(0,listNode.val);//头插法
            listNode=listNode.next;
        }
        return ret;
    }
}

/*
*使用头插法构建逆序链表
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //头插法构建逆序链表
        ListNode head=new ListNode(-1);//创建头结点
        while(listNode!=null){
            ListNode temp=listNode.next;//temp保存下一个结点位置
            //将当前结点插入head后面
            listNode.next=head.next;
            head.next=listNode;
            //将temp保存位置赋给listNode，准备开始下一次循环
            listNode=temp;
        }
        //构建ArrayList
        ArrayList<Integer> ret=new ArrayList<> ();
        head=head.next;
        while(head!=null){
            ret.add(head.val);//尾插法
            head=head.next;
        }
        return ret;
    }
}
```

- 利用栈的LIFO性质，stack.push()，stack.pop()。

  区分：stack.peek()只返回栈顶的值，不删除栈顶的值

```java
/*
*利用栈的LIFO性质
*/
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //构建栈，将链表依序读入栈中
        Stack <Integer> stack=new Stack<>();
        while(listNode!=null){
            stack.push(listNode.val);
            listNode=listNode.next;
        }
        //构建ArrayList
        ArrayList<Integer> ret=new ArrayList<> ();
        //将栈中元素弹出直至栈空，实现逆序输出
        while(!stack.empty()){
            ret.add(stack.pop());
        }
        return ret;
    }
}
```



## Map



## 哈希表



## 树

### 重建二叉树

[nowcoder](<https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

#### 解题思路

- 前序遍历的第一个值为根节点的值，查找出该值在中序遍历中的位置，即可将其分为两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。接着进行递归重建左子树和右子树
- 通过画简单的示意图，确定左、右子树的前序遍历和中序遍历在两数组中的索引范围

**利用 HashMap**

```java
import java.util.HashMap;
public class Solution {
    private HashMap<Integer,Integer> indexForInOrders = new HashMap<>();
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        //用 HashMap 存储中序遍历的结果和索引
        for(int i=0;i<in.length;i++)
            indexForInOrders.put(in[i],i);
        return(reConstructBinaryTree(pre,0,pre.length-1,0));
    }
    //preL为树的起点，preR为树的终点，inL为中序遍历中树的起点
    private TreeNode reConstructBinaryTree(int [] pre,int preL,int preR,int inL){
        if(preL>preR)
            return null;
        TreeNode root=new TreeNode (pre[preL]);
        int inIndex=indexForInOrders.get(root.val);//中序遍历中查找根节点的索引值
        int leftTreeSize=inIndex-inL;//左子树的大小=根结点位置（中）-左子树起始位置（中）
        //要注意计算左右子树的范围
        root.left=reConstructBinaryTree(pre,preL+1,preL+leftTreeSize,inL);
        root.right=reConstructBinaryTree(pre,preL+leftTreeSize+1,preR,inIndex+1);
        return root;
    }
}
```

**直接遍历比较查找根节点**

```java
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        return reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);
    }
    //preL为树的起点，preR为树的终点，inL为中序遍历中树的起点
    private TreeNode reConstructBinaryTree(int [] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd){
        if(preStart>preEnd||inStart>inEnd)
            return null;
        TreeNode root=new TreeNode (pre[preStart]);
        for(int i=0;i<=inEnd;i++){
            if(in[i]==pre[preStart]){//在中序遍历中查找根节点的位置i
                int leftTreeSize=i-inStart;//左子树的大小=根结点位置（中）-左子树起始位置（中）
                //要注意计算左右子树的范围
                root.left=reConstructBinaryTree(pre,preStart+1,preStart+leftTreeSize,in,inStart,i-1);
                root.right=reConstructBinaryTree(pre,preStart+leftTreeSize+1,preEnd,in,i+1,inEnd);
                break;
            }
        }
        return root;
    }
}
```

## 二叉搜索树



## 深度优先搜索



## 广度优先搜索



## 递归



## 动态规划



## 回溯算法



## 二分查找



## 分治算法



## 位运算



## 排序



## 贪心算法



## 并查集



## 图



## 数学



## 设计



## 拓扑排序



## 字典树



## 树状数组



## 线段树



## 脑筋急转弯



## 记忆化



## 极大化极小化



## 蓄水池抽样



## 几何









