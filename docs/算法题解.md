## 数组

### LeetCode 75

[LeetCode 75](<https://leetcode-cn.com/problems/sort-colors/>)

#### 颜色排序

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:不能使用代码库中的排序函数来解决这道题。

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

#### **解题思路**

1. ##### **计数排序**思想

- 第一次遍历数组，迭代计算为0、 1 和 2 的元素个数；
- 第二次遍历，按照0，1，2 的排序，重写当前数组。

时间复杂度为 O(n)；空间复杂度为 O(k)（元素种类为 k，这里  `k=3` ,创建了 `int[] cnts = new int[3];` ）。

```java
//leetcode-75
//采用计数排序
class Solution {
    public void sortColors(int[] nums) {
        int[] cnts = new int[3];
        for(int num : nums){
            if(num == 0){
                cnts[0]++;
            }else if(num == 1){
                cnts[1]++;
            }else{
                cnts[2]++;
            }
        }
        for(int i = 0;i < nums.length;i++){
            if(i < cnts[0]){
                nums[i] = 0;
            }else if(i >= cnts[0] && i < cnts[0] + cnts[1]){
                nums[i] = 1;
            
            }else{
                nums[i] = 2;
            }
        }        
    }
}
```

2. ##### 三路快排

时间复杂度为 O(n)；不需要额外空间。

```java
class Solution {
    public void sortColors(int[] nums) {
        int l = -1;//nums[0...l] == 0
        int h = nums.length;//nums[h...nums.length-1] == 2
        for(int i = 0;i < h;){
            if(nums[i] == 1){
                i++;
            }else if(nums[i] == 2){
                h--;
                swap(nums, i, h);
            }else{
                l++;
                swap(nums, i, l);
                i++;
            }            
        }        
    }
    private void swap(int[] nums,int a,int b){
        int t = nums[a];
        nums[a] = nums[b];
        nums[b] = t;
    }
}
```

[leetcode-88](<https://leetcode-cn.com/problems/merge-sorted-array/>)

[leetcode-215](<https://leetcode-cn.com/problems/kth-largest-element-in-an-array/>)

### 二维数组中的查找

[nowcoder](<https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 解题思路

- 需要充分利用该二维数组的特点（从左到右递增排序，从上到下也是递增排序），找出解题方法。
- 从**右上角/左下角**开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间
- 没有单独处理输入数组为空或非二维数组的情况。**要先对特殊情况做处理**。

```java
public class Solution {
    public boolean Find(int target, int [][] array) {
        //若输入的不是二维数组，返回false
        if(array==null||array.length==0||array[0].length==0)
            return false;
        //从数组的右上角开始与target比较
        int row=0;
        int col=array[0].length-1;
        while(row<array.length&&col>=0){
            if(target>array[row][col])
                row++;
            else if(target<array[row][col])
                col--;
            else
                return true;
        }
        return false;
    }
}
```

### 数组中重复的数字

[nowcoder](<https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

#### 解题思路

对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。

以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复。

```java
/*
将值为i的元素调整到第i个位置上
调整前比较当前值为i的元素与第i个位置上的元素值是否相等
若相等，则该元素值重复
*/
public class Solution {
    public boolean duplicate(int[] numbers,int length,int [] duplication) {
        //输入数组为空或数组长度不符合
        if(numbers==null||length<=0){
            return false;
        }
        //遍历数组元素
        for(int i=0;i<length;i++){
            if(numbers[i]<0||numbers[i]>=length)
                return false;//判断数组元素是否在规定范围内
            while(numbers[i]!=i){//直到numbers[i]==i时，才会i++，比较下一个
                if(numbers[i]==numbers[numbers[i]]){
                    duplication[0]=numbers[i];//出现重复数字
                    return true;
                }
                swap(numbers,numbers[i],i);
            }
        }
        return false;
    }
    public void swap(int[] numbers,int x,int y){
        int temp=numbers[y];
        numbers[y]=numbers[x];
        numbers[x]=temp;
    }
}
```



## 字符串

### 替换空格

[nowcoder](<https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 解题思路

- 先遍历一遍，确定空格数量，每有一个空格在str尾部填充两个字符；
- 再由后向前遍历，这里设置 P1（指向原字符串末尾后面一个位置）, P2（指向添加空格后的新字符串末尾后面一个位置） 两个指针，根据 P1 向前遍历的结果，确定当前 P2 位置的内容；
  - 若 P1 位置为空格，则 P2 位置及其前两个位置依次改为 ’0‘，’2‘，’%‘；
  - 若 P1 位置不为空格，则 P2 位置改为 当前 P1 位置存储的字符 c。
- 要注意**索引下标**的正确性，P--，--P 要仔细考虑一下，否则会出现越界错误：java.lang.StringIndexOutOfBoundsException: String index out of range: -1

```java
public class Solution {
    public String replaceSpace(StringBuffer str) {
        int P1=str.length();
        //先遍历一遍，确定空格数量，每有一个空格在str尾部填充两个字符
        for(int i=0;i<P1;i++){
            if(str.charAt(i)==' ')
                str.append("  ");//尾部添加两个空格
        }
        //由后向前遍历，不会影响到P1遍历原来字符串的内容
        int P2=str.length();
        while(P1>0||P1<P2){
            char c=str.charAt(--P1);
            if(c==' '){
                str.setCharAt(--P2,'0');
                str.setCharAt(--P2,'2');
                str.setCharAt(--P2,'%');
            }
            else{
                str.setCharAt(--P2,c);
            }
        }
        return str.toString();
    }
}
```



## 栈

### 用两个栈实现队列

[nowcoder](<https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

#### 解题思路

- 两个栈，一个栈（in）处理入栈操作，一个栈（out）处理出栈操作。
- 队列先进先出，而栈后进先出，关键在于出队前，需要将栈中元素顺序进行反转，故每次pop操作需要将in中元素pop并依序push到out中，实现顺序的反转，再进行出队pop操作。
- 若考虑到push和pop是多次操作的，那么第二次push操作，也需要用同样的方法将新的队列从out栈中push到in栈中，再进行入队push操作。
- **进时，栈out是否为空，不为空，则栈out元素倒回到栈in，出时，将栈in元素全部弹到栈out中，直到栈in为空。**

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> in = new Stack<Integer>();
    Stack<Integer> out = new Stack<Integer>();
    //push:若in队列为空，则将out依次弹出，并push到in，实现栈中顺序的反转
    public void push(int node)  throws Exception {
        if(in.isEmpty()){
            while(!out.isEmpty())
                in.push(out.pop());
        }
        in.push(node);//push本次的新结点进入队列
    }
    //pop:若out队列为空，则将in依次弹出，并push到out，实现栈中顺序的反转
    public int pop() throws Exception {
        if(out.isEmpty()){
            while(!in.isEmpty())
                out.push(in.pop());
        }
        return out.pop();
    }
}
```



## 堆



## 队列



## 链表

### 从尾到头打印链表

[nowcoder](<https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

#### 解题思路

三种方法：**递归，头插法，栈**

- 递归：需要明确**递归边界**和**递归逻辑**，**一层一层调用，直到递归结束条件成立，再一层一层返回**。配合addAll()，按序将返回值添加到ArrayList尾部。

```java
/*
*使用递归
*不停的对listNode.next递归调用，直至最后一个结点
*再开始回溯插入ArrayList中，实现逆序
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> ret=new ArrayList<> ();
        if(listNode!=null){
            //addAll()按照返回的元素顺序，插入到arrayList中
            ret.addAll(printListFromTailToHead(listNode.next));//递归调用
            ret.add(listNode.val);//当前结点值插入arrayList
        }
        return ret;
    }
}
```

- 头插法：
  - 直接用add(index=0,element)头插法构建ArrayList
  - 用头插法构建逆序链表,再用add(element)尾插法构建ArrayList

```java
/*
*使用 add(0,listNode.val) 头插法实现逆序
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> ret=new ArrayList<> ();
        while(listNode!=null){
            ret.add(0,listNode.val);//头插法
            listNode=listNode.next;
        }
        return ret;
    }
}

/*
*使用头插法构建逆序链表
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //头插法构建逆序链表
        ListNode head=new ListNode(-1);//创建头结点
        while(listNode!=null){
            ListNode temp=listNode.next;//temp保存下一个结点位置
            //将当前结点插入head后面
            listNode.next=head.next;
            head.next=listNode;
            //将temp保存位置赋给listNode，准备开始下一次循环
            listNode=temp;
        }
        //构建ArrayList
        ArrayList<Integer> ret=new ArrayList<> ();
        head=head.next;
        while(head!=null){
            ret.add(head.val);//尾插法
            head=head.next;
        }
        return ret;
    }
}
```

- 利用栈的LIFO性质，stack.push()，stack.pop()。

  区分：stack.peek()只返回栈顶的值，不删除栈顶的值

```java
/*
*利用栈的LIFO性质
*/
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        //构建栈，将链表依序读入栈中
        Stack <Integer> stack=new Stack<>();
        while(listNode!=null){
            stack.push(listNode.val);
            listNode=listNode.next;
        }
        //构建ArrayList
        ArrayList<Integer> ret=new ArrayList<> ();
        //将栈中元素弹出直至栈空，实现逆序输出
        while(!stack.empty()){
            ret.add(stack.pop());
        }
        return ret;
    }
}
```



## Map



## 哈希表



## 树

### 重建二叉树

[nowcoder](<https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

#### 解题思路

- 前序遍历的第一个值为根节点的值，查找出该值在中序遍历中的位置，即可将其分为两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。接着进行递归重建左子树和右子树
- 通过画简单的示意图，确定左、右子树的前序遍历和中序遍历在两数组中的索引范围

**利用 HashMap**

```java
import java.util.HashMap;
public class Solution {
    private HashMap<Integer,Integer> indexForInOrders = new HashMap<>();
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        //用 HashMap 存储中序遍历的结果和索引
        for(int i=0;i<in.length;i++)
            indexForInOrders.put(in[i],i);
        return(reConstructBinaryTree(pre,0,pre.length-1,0));
    }
    //preL为树的起点，preR为树的终点，inL为中序遍历中树的起点
    private TreeNode reConstructBinaryTree(int [] pre,int preL,int preR,int inL){
        if(preL>preR)
            return null;
        TreeNode root=new TreeNode (pre[preL]);
        int inIndex=indexForInOrders.get(root.val);//中序遍历中查找根节点的索引值
        int leftTreeSize=inIndex-inL;//左子树的大小=根结点位置（中）-左子树起始位置（中）
        //要注意计算左右子树的范围
        root.left=reConstructBinaryTree(pre,preL+1,preL+leftTreeSize,inL);
        root.right=reConstructBinaryTree(pre,preL+leftTreeSize+1,preR,inIndex+1);
        return root;
    }
}
```

**直接遍历比较查找根节点**

```java
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        return reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);
    }
    //preL为树的起点，preR为树的终点，inL为中序遍历中树的起点
    private TreeNode reConstructBinaryTree(int [] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd){
        if(preStart>preEnd||inStart>inEnd)
            return null;
        TreeNode root=new TreeNode (pre[preStart]);
        for(int i=0;i<=inEnd;i++){
            if(in[i]==pre[preStart]){//在中序遍历中查找根节点的位置i
                int leftTreeSize=i-inStart;//左子树的大小=根结点位置（中）-左子树起始位置（中）
                //要注意计算左右子树的范围
                root.left=reConstructBinaryTree(pre,preStart+1,preStart+leftTreeSize,in,inStart,i-1);
                root.right=reConstructBinaryTree(pre,preStart+leftTreeSize+1,preEnd,in,i+1,inEnd);
                break;
            }
        }
        return root;
    }
}
```

### 二叉树的下一结点

[nowcoder](<https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking>)

给定一个二叉树和其中的一个结点（pNode），请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

#### 解题思路

- 要注意到题目中给出的 TreeLinkNode next  即为当前结点指向父结点的指针
- 如果当前结点的右子树存在，那么返回右子树的最左叶子结点（即右子树中最先遍历的结点）
- 如果当前结点的右子树不存在：
  - 若当前结点为父结点的左结点，那么返回当前结点的父结点
  - 若当前结点为父结点的右结点，那么继续向上遍历父结点的父结点，直到找到一个结点是其父结点的左子结点，返回该结点

```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        //右子树为空，向上找第一个左链指向节点所在子树的祖先节点
        if(pNode.right==null){
            while(pNode.next!=null){
                TreeLinkNode parent=pNode.next;//父节点
                if(parent.left==pNode)
                    return parent;//若为左链，返回值
                pNode=parent;//非左链，继续向上遍历祖先节点
            }
            return null;
        }else{
            //右子树不为空，返回右子树的最左节点
            TreeLinkNode node=pNode.right;
            //沿左链一直向下遍历，直至叶子节点
            while(node.left!=null)
                node=node.left;
            return node;
        }
    }
}
```



## 二叉搜索树



## 深度优先搜索



## 广度优先搜索



## 递归

### 斐波那契数列

[nowcoder](<https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。

n<=39

#### 解题思路

- 递归，每次递归需要重复计算子问题，效率极低，需要指数级时间（运行时间1263 ms，占用内存9272 K）
- 动态规划，建立一个数组，把子问题的解缓存起来，避免重复计算，需要线性时间，空间复杂度度为O(N)
- 只存储前两项的值，空间复杂度为O(1)
- 直接将前 40 项全部计算后保存

[浅谈动态规划](<https://blog.csdn.net/feizaoSYUACM/article/details/53846323>)

> 每个阶段只有一个状态->**递推**；
>
> 每个阶段的最优状态都是由上一个阶段的最优状态得到的->**贪心**；
>
> 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->**搜索**；
>
> 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->**动态规划**。

```java
//递归，每次递归需要重复计算子问题，时间效率低
public class Solution {
    public int Fibonacci(int n) {
        if(n<=1)
            return n;
        return Fibonacci(n-1)+Fibonacci(n-2);
    }
}

//动态规划
public class Solution {
    public int Fibonacci(int n) {
        if(n<=1)
            return n;
        int[] f=new int[n+1];
        f[1]=1;
        for(int i=2;i<n+1;i++)
            f[i]=f[i-1]+f[i-2];
        return f[n];
    }
}

//只存储前两项的值
public class Solution {
    public int Fibonacci(int n) {
        if(n<=1)
            return n;
        int p2=0,p1=1,f=0;
        for(int i=2;i<=n;i++){
            f=p2+p1;
            p2=p1;
            p1=f;
        }
        return f;
    }
}

//直接将前 40 项全部计算后保存
public class Solution {
    private int[] f=new int[40];
    public Solution(){
        f[1]=1;
        for(int i=2;i<f.length;i++){
            f[i]=f[i-1]+f[i-2];
        }
    }
    public int Fibonacci(int n) {
        return f[n];
    }
}
```



## 动态规划

### 矩形覆盖

[nowcoder](<https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

我们可以用 2\*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2\*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共有多少种方法？

#### 解题思路

1. n<= 0 大矩形为<= 2*0,直接return 0； 

2. n= 1大矩形为2\*1，只有一种摆放方法，return 1；

3. n= 2 大矩形为2\*2，有两种摆放方法，return 2；

4. n>2分为两步考虑： 

   第一次摆放一块 2*1 的小矩阵，则摆放方法总共为f(n- 1)

|  √   |      |      |      |      |
| :--: | ---- | ---- | ---- | ---- |
|  √   |      |      |      |      |

​	第一次摆放一块1*2的小矩阵，则摆放方法总共为f(n-2)

|  √   |  √   |      |      |      |
| :--: | :--: | ---- | ---- | ---- |
|      |      |      |      |      |

故：f(n)=f(n-1)+f(n-2)

```java
//斐波那契数列，动态规划
public class Solution {
    public int RectCover(int n) {
        if(n<=1)
            return n;
        int[] f=new int[n+1];
        f[1]=1;
        f[2]=2;
        for(int i=3;i<n+1;i++)
            f[i]=f[i-1]+f[i-2];
        return f[n];
    }
}
```

### 跳台阶

[nowcoder](<https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking>)

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

#### 解题思路

- 动态规划，同[矩形覆盖](#矩形覆盖)，建立一个数组保存各个子问题的解，避免重复计算
- 数学推导，先推导出数学关系，后直接用公式计算





## 回溯算法



## 二分查找



## 分治算法



## 位运算



## 排序



## 贪心算法



## 并查集



## 图



## 数学



## 设计



## 拓扑排序



## 字典树



## 树状数组



## 线段树



## 脑筋急转弯



## 记忆化



## 极大化极小化



## 蓄水池抽样



## 几何









